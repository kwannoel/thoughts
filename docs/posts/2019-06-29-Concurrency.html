<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Wipe Your Glasses - Concurrency in Haskell</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Wipe Your Glasses</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
                <a href="../Project ideas.html">Project ideas</a>
            </div>
        </div>

        <div id="content">
            <h1>Concurrency in Haskell</h1>

            <div class="info">
    Posted on June 29, 2019
    
</div>

<p>NOTE: You may reference Control.Currency for a more up to date insight.</p>
<p>In this post I am exploring something called forkIO. Here is the context:</p>
<p>We are creating a simple backend server. This server has a <code>SQLite</code> db instance hosted.</p>
<p>What we like to do here is host the server, doing two things: - Listening for queries via <code>finger</code>, - Allowing updates &amp; injections of user data to the <code>db</code> instance</p>
<p>As a result we would need to fork the main process, to allow us to continue listening(first process) while we inject the user data into the db (second process).</p>
<hr />
<p><em>Do let me know if I get any of this wrong :P</em></p>
<p>Material referenced: http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz</p>
<hr />
<p>Takeaways: - impractical to do IO with side-effecting functions: - sub-expr eval is context specific due to <code>non-strictness</code> of haskell - MutVars are references to a mutable location in the state - state-transformer semantics for I/O are unsatisfactory because we do not want the side-effects to be updated simultaneously but rather incrementally - Concurrent Haskell introduces: - processes &amp;&amp; process init - atomically mutable state: Support inter process comms &amp;&amp; coop - concurrency is non-deterministic, - we may have 2 processes writing to the file, of which the outcome is unknown - forkIO requires inter-process syncing: Evaluation of thunks can be synced</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
